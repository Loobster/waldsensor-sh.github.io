<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Waldsensor SH (Testkarte)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .blinking {
      animation: blinker 3.5s linear infinite;
    }
    @keyframes blinker {
      50% { opacity: 0.3; }
    }
    .distance-tooltip {
      background-color: white;
      border: 1px solid black;
      padding: 2px 4px;
      font-size: 11px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="scripts/oms.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-ant-path@1.3.0/dist/leaflet-ant-path.min.js"></script>

  <script>
    const map = L.map("map").setView([54.6, 9.0], 9);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OSM</a>',
    }).addTo(map);

    const oms = new OverlappingMarkerSpiderfier(map);
    const gwInfo = {};
    const activeGatewayMarkers = {};

    const nodeFiles = [
      "data/lsn50v2.json",
      "data/s31lb.json",
      "data/se01lb.json",
      "data/sn50v3.json"
    ];
    const gatewayDB = "data/gateways.json";

    async function loadGateways() {
      const res = await fetch(gatewayDB);
      const gateways = await res.json();
      for (const gw of gateways) {
        gwInfo[gw.id] = gw;
      }
    }

    async function loadNodes() {
      for (const file of nodeFiles) {
        try {
          const res = await fetch(file);
          const nodeData = await res.json();

          const { node, position, time, gateways, values } = nodeData;
          const timestamp = new Date(time);
          const now = new Date();

          if (!position || position.lat === 0.0 || position.lon === 0.0) {
            console.warn(`‚ö†Ô∏è Ung√ºltige Position f√ºr Node: ${node} (${file})`);
            continue;
          }

          // Werte anzeigen
          let valuesHtml = "";
          if (values && typeof values === "object") {
            for (const [key, value] of Object.entries(values)) {
              valuesHtml += `<br><b>${key}</b>: ${value}`;
            }
          }

          // Node-Marker (blauer Kreis)
          const marker = L.circleMarker([position.lat, position.lon], {
            radius: 5,
            color: "#0077ff",
            fillColor: "#3399ff",
            fillOpacity: 0.8,
            weight: 2
          })
          .bindPopup(`
            <b>Sensor:</b> ${node}<br>
            <b>Zuletzt aktiv:</b> ${timestamp.toLocaleString()}
            ${valuesHtml}
          `)
          .addTo(map);

          oms.addMarker(marker);

          // Gateways (nur bei frischer √úbertragung)
          if ((now - timestamp) < 5 * 60 * 1000) {
            for (const gw of gateways) {
              const g = gwInfo[gw.id];
              if (!g || !g.lat || !g.lon || g.lat === 0.0 || g.lon === 0.0) {
                console.warn(`‚ö†Ô∏è Ung√ºltige Gateway-Position: ${gw.id}`);
                continue;
              }

              const gwMarker = L.circleMarker([g.lat, g.lon], {
                radius: 8,
                color: "#f00",
                weight: 2,
                fillOpacity: 0.7,
                className: "blinking"
              }).bindPopup(`
                <b>Gateway:</b> ${g.name || gw.id}<br>
                <b>Empf√§ngt von:</b> ${node}<br>
                RSSI: ${gw.rssi} / SNR: ${gw.snr}
              `).addTo(map);

              activeGatewayMarkers[gw.id] = gwMarker;

              // üî¥ Ant-Line (animierte Verbindung)
              const antLine = L.polyline.antPath([
                [position.lat, position.lon],
                [g.lat, g.lon]
              ], {
                delay: 1000,
                dashArray: [10, 20],
                weight: 2,
                color: "transparent",
                pulseColor: "rgba(255, 0, 0, 0.5)",
                paused: false,
                reverse: false,
                hardwareAccelerated: true
              }).addTo(map);

              // üß≠ Entfernung anzeigen
              const tooltipLine = L.polyline([
                [position.lat, position.lon],
                [g.lat, g.lon]
              ], {
                color: 'transparent',
                weight: 10,
                opacity: 0
              }).addTo(map);

              const distance = map.distance([position.lat, position.lon], [g.lat, g.lon]) / 1000;
              tooltipLine.bindTooltip(`${distance.toFixed(1)} km`, {
                sticky: true,
                direction: 'top',
                className: 'distance-tooltip',
                offset: [0, -5],
                opacity: 1
              });

              // Entfernen nach 30 Sekunden
              setTimeout(() => {
                map.removeLayer(gwMarker);
                map.removeLayer(antLine);
                map.removeLayer(tooltipLine);
              }, 30000);
            }
          }

        } catch (error) {
          console.error(`‚ùå Fehler beim Laden von ${file}:`, error);
        }
      }
    }

    async function init() {
      await loadGateways();
      await loadNodes();
    }

    init();

    setInterval(() => {
      for (const id in activeGatewayMarkers) {
        map.removeLayer(activeGatewayMarkers[id]);
        delete activeGatewayMarkers[id];
      }
      loadNodes();
    }, 60000);
  </script>
</body>
</html>