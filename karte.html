<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Waldsensor SH (Testkarte)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .blinking {
      animation: blinker 1s linear infinite;
    }
    @keyframes blinker {
      50% { opacity: 0.3; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="scripts/oms.min.js"></script>

  <script>
    const map = L.map("map").setView([54.6, 9.0], 9);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OSM</a>',
    }).addTo(map);

    const oms = new OverlappingMarkerSpiderfier(map);
    const gwInfo = {};
    const activeGatewayMarkers = {};

    const nodeFiles = [
      "data/lsn50v2.json",
      "data/s31lb.json",
      "data/se01lb.json",
      "data/sn50v3.json"
    ];
    const gatewayDB = "data/gateways.json";

    async function loadGateways() {
      const res = await fetch(gatewayDB);
      const gateways = await res.json();
      for (const gw of gateways) {
        gwInfo[gw.id] = gw;
      }
    }

    async function loadNodes() {
      for (const file of nodeFiles) {
        try {
          const res = await fetch(file);
          const nodeData = await res.json();

          const { node, position, time, gateways, values } = nodeData;
          const timestamp = new Date(time);
          const now = new Date();

          if (!position || position.lat === 0.0 || position.lon === 0.0) {
            console.warn(`⚠️ Ungültige Position für Node: ${node} (${file})`);
            continue;
          }

          // Werte anzeigen
          let valuesHtml = "";
          if (values && typeof values === "object") {
            for (const [key, value] of Object.entries(values)) {
              valuesHtml += `<br><b>${key}</b>: ${value}`;
            }
          }

          // Node-Marker (blauer Kreis)
          const marker = L.circleMarker([position.lat, position.lon], {
            radius: 10,
            color: "#0077ff",
            fillColor: "#3399ff",
            fillOpacity: 0.8,
            weight: 2
          })
          .bindPopup(`
            <b>Sensor:</b> ${node}<br>
            <b>Zuletzt aktiv:</b> ${timestamp.toLocaleString()}
            ${valuesHtml}
          `)
          .addTo(map);

          oms.addMarker(marker);

          // Gateways (nur anzeigen, wenn Node frisch ist)
          if ((now - timestamp) < 5 * 60 * 1000) {
            for (const gw of gateways) {
              const g = gwInfo[gw.id];
              if (!g || !g.lat || !g.lon || g.lat === 0.0 || g.lon === 0.0) {
                console.warn(`⚠️ Ungültige Gateway-Position: ${gw.id}`);
                continue;
              }

              const gwMarker = L.circleMarker([g.lat, g.lon], {
                radius: 8,
                color: "#f00",
                weight: 2,
                fillOpacity: 0.7,
                className: "blinking"
              }).bindPopup(`
                <b>Gateway:</b> ${g.name || gw.id}<br>
                <b>Empfängt von:</b> ${node}<br>
                RSSI: ${gw.rssi} / SNR: ${gw.snr}
              `).addTo(map);

              activeGatewayMarkers[gw.id] = gwMarker;

              setTimeout(() => {
                map.removeLayer(gwMarker);
                delete activeGatewayMarkers[gw.id];
              }, 30000); // 30 Sekunden sichtbar
            }
          }
        } catch (error) {
          console.error(`❌ Fehler beim Laden von ${file}:`, error);
        }
      }
    }

    async function init() {
      await loadGateways();
      await loadNodes();
    }

    init();

    setInterval(() => {
      for (const id in activeGatewayMarkers) {
        map.removeLayer(activeGatewayMarkers[id]);
        delete activeGatewayMarkers[id];
      }
      loadNodes();
    }, 60000); // 1-Minuten-Update
  </script>
</body>
</html>