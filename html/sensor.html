<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Schulwaldsensor ‚Äî ‚Ä¶</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root{--bg:#f6f8fb;--card:#fff;--muted:#8a93a3;--ink:#0d1b2a;--ok:#dff6e5;--pad:16px;--radius:14px}
    html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans","Helvetica Neue",sans-serif}
    .wrap{max-width:1180px;margin:0 auto;padding:20px}
    h1{font-weight:800;letter-spacing:.2px;margin:6px 0 18px;font-size:clamp(26px,4vw,40px)}
    .row{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.row{grid-template-columns:1.1fr .9fr}}
    .card{background:var(--card);border-radius:var(--radius);box-shadow:0 1px 0 rgba(0,0,0,.04),0 10px 30px -20px rgba(0,0,0,.15);padding:var(--pad)}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--ok);color:#115e59;font-weight:700;font-size:14px}
    .grid3{display:grid;gap:12px;grid-template-columns:1fr}
    @media(min-width:700px){.grid3{grid-template-columns:repeat(2,1fr)}}
    @media(min-width:980px){.grid3{grid-template-columns:repeat(3,1fr)}}
    .tile{background:#eef2f7;border-radius:12px;padding:14px 16px;min-height:86px;display:flex;flex-direction:column;justify-content:center}
    .k{color:var(--muted);font-size:14px;margin-bottom:6px}
    .v{font-size:22px;font-weight:800;letter-spacing:.2px}
    .muted{color:var(--muted)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    canvas{max-height:360px} .hint{margin-top:8px;font-size:13px;color:var(--muted)}
    .section-title{font-weight:800;margin:0 0 10px}
    a.back{text-decoration:none;color:#2563eb;font-weight:600}
    .err{color:#b91c1c;font-weight:700}
  </style>
</head>
<body>
  <div class="wrap">
    <div style="margin-bottom:8px;"><a class="back" href="/v2.html">‚Üê Zur Karte</a></div>
    <h1>Schulwaldsensor ‚Äî <span id="nodeTitle">‚Ä¶</span></h1>

    <div class="row">
      <div class="card">
        <div style="margin-bottom:10px;">
          <span class="pill">Stand: <span id="stand">‚Äî</span></span>
        </div>
        <div class="grid3">
          <div class="tile"><div class="k">Temperatur</div><div class="v" id="temp">‚Äî</div></div>
          <div class="tile"><div class="k" id="humLabel">Luftfeuchte</div><div class="v" id="hum">‚Äî</div></div>
          <div class="tile" style="grid-column:1/-1"><div class="k">Batterie</div><div class="v" id="bat">‚Äî</div></div>
        </div>
        <div class="hint">Quelle: <span class="mono">/data/v2/latest/_all.json</span></div>
      </div>

      <div class="card">
        <div class="section-title">Aktuelle Werte</div>
        <div class="muted" id="aktuell">‚Äî</div>
        <div id="netStats" style="margin-top:12px"></div>
      </div>
    </div>

    <div class="card" style="margin-top:18px;">
      <div class="section-title">üìä Verlauf Temperatur &amp; Luftfeuchtigkeit</div>
      <canvas id="chartHourly"></canvas>
      <div class="hint">Sucht: <span id="histPath" class="mono">/data/v2/history/&lt;node&gt;.json</span></div>
      <div class="hint err" id="histErr" style="display:none"></div>
      <div class="hint" id="noHourly" style="display:none">Kein Verlauf gefunden.</div>
    </div>

    <div class="card" style="margin-top:18px;">
      <div class="section-title">üóìÔ∏è 31 Tage ‚Äî Tagesmittel (Temp / Feuchte)</div>
      <canvas id="chartDaily"></canvas>
      <div class="hint" id="noDaily" style="display:none">Keine Tageswerte m√∂glich (es fehlt Verlauf).</div>
    </div>
  </div>

  <script>
    const byId = (id) => document.getElementById(id);
    const fmt = (n, d=1) => (n==null || Number.isNaN(n)) ? "‚Äî" : Number(n).toFixed(d).replace(".",",");
    const isSoilNode = (id) => id === "se01";

    function detectNode(){
      const u = new URL(location.href);
      let raw = (u.searchParams.get("node")||u.searchParams.get("id")||"").trim();
      if(!raw && location.hash){
        const sp = new URLSearchParams(location.hash.slice(1));
        raw = (sp.get("node")||"").trim();
      }
      if(!raw){
        let p = (location.pathname.split("/").pop()||"").replace(/\.html?$/,"");
        raw = (p==="sensor") ? "" : p;
      }
      return (raw||"").replace(/[\r\n]+/g,"").trim() || null;
    }

    async function loadLatest(){
      const r = await fetch("/data/v2/latest/_all.json",{cache:"no-store"});
      if(!r.ok) throw new Error("Live-Quelle nicht erreichbar: "+r.status);
      const arr = await r.json();
      return arr.map(x=>({...x,id:(x.id||"").replace(/[\r\n]+/g,"").trim()}));
    }

    function pickFields(entry){
      const f = entry.fields||{};
      if(isSoilNode(entry.id)){
        return {temp: f.temp_SOIL ?? null, hum: f.water_SOIL ?? null, bat: f.BatV ?? null, humLabel:"Bodenwasser"};
      }
      return {
        temp: f.TempC_SHT ?? f.TempC_SHT31 ?? null,
        hum:  f.Hum_SHT   ?? f.Hum_SHT31   ?? null,
        bat:  f.BatV ?? null,
        humLabel:"Luftfeuchte"
      };
    }

    async function loadHistory(node){
      const url = `/data/v2/history/${encodeURIComponent(node)}.json`;
      byId("histPath").textContent = url;
      const r = await fetch(url,{cache:"no-store"});
      if(!r.ok){
        byId("histErr").style.display="block";
        byId("histErr").textContent = `Fehler beim Laden (${r.status}) von ${url}`;
        return [];
      }
      byId("histErr").style.display="none";
      let data = await r.json();
      if(!Array.isArray(data)) return [];
      data = data.filter(x=>x && x.ts).sort((a,b)=>new Date(a.ts)-new Date(b.ts));
      return data;
    }

    let chH, chD;
    function makeHourlyChart(ctx, items, soil){
      const labels = items.map(x=>x.ts);
      const temps  = items.map(x=>x.t);
      const hums   = items.map(x=>x.h);
      const tLabel = soil? "Bodentemperatur [¬∞C]":"Temperatur [¬∞C]";
      const hLabel = soil? "Bodenwasser [%]"    :"Luftfeuchte [%]";
      if(ctx._chart) ctx._chart.destroy();
      ctx._chart = new Chart(ctx,{type:'line',data:{
        labels,
        datasets:[{label:tLabel,data:temps,yAxisID:'y1'},{label:hLabel,data:hums,yAxisID:'y2'}]
      },options:{
        responsive:true,interaction:{mode:'index',intersect:false},
        scales:{
          x:{ticks:{callback:(v,i)=>{const d=new Date(labels[i]);return d.toLocaleDateString("de-DE",{day:"2-digit",month:"2-digit"})+" "+d.toLocaleTimeString("de-DE",{hour:"2-digit"})+"h"}}},
          y1:{position:'left',title:{display:true,text:tLabel},grid:{drawOnChartArea:false}},
          y2:{position:'right',title:{display:true,text:hLabel},min:0,max:100}
        },plugins:{legend:{position:'top'}}
      }});
      return ctx._chart;
    }

    function makeDailyChart(ctx, days, soil){
      const labels = days.map(x=>x.day), temps=days.map(x=>x.t), hums=days.map(x=>x.h);
      const tLabel = soil? "√ò Bodentemperatur [¬∞C]":"√ò Temperatur [¬∞C]";
      const hLabel = soil? "√ò Bodenwasser [%]"    :"√ò Luftfeuchte [%]";
      if(ctx._chart) ctx._chart.destroy();
      ctx._chart = new Chart(ctx,{type:'bar',data:{
        labels,
        datasets:[{type:'bar',label:hLabel,data:hums,yAxisID:'y2'},{type:'line',label:tLabel,data:temps,yAxisID:'y1'}]
      },options:{
        responsive:true,interaction:{mode:'index',intersect:false},
        scales:{y1:{position:'left',title:{display:true,text:tLabel},grid:{drawOnChartArea:false}},y2:{position:'right',title:{display:true,text:hLabel},min:0,max:100}},
        plugins:{legend:{position:'top'}}
      }});
      return ctx._chart;
    }

    function groupDaily(items){
      const m = new Map();
      for(const it of items){
        const d = new Date(it.ts);
        const key = d.getUTCFullYear()+"-"+String(d.getUTCMonth()+1).padStart(2,"0")+"-"+String(d.getUTCDate()).padStart(2,"0");
        if(!m.has(key)) m.set(key,{n:0,tsum:0,hsum:0});
        const o = m.get(key);
        if(typeof it.t==="number") o.tsum+=it.t;
        if(typeof it.h==="number") o.hsum+=it.h;
        o.n++;
      }
      const out=[];
      for(const [k,v] of m.entries()) out.push({day:k,t:v.n? v.tsum/v.n:null,h:v.n? v.hsum/v.n:null});
      out.sort((a,b)=>a.day.localeCompare(b.day));
      return out.slice(-31);
    }

    /* ------- Netzwerk/Gateway-Teil ------- */

    async function loadLinks(node){
      const url = `/data/v2/links/${encodeURIComponent(node)}.json`;
      try{
        const r = await fetch(url, {cache:"no-store"});
        if(!r.ok) return [];
        const arr = await r.json();
        return Array.isArray(arr) ? arr.filter(x=>x && x.ts && x.gw_id) : [];
      }catch{ return []; }
    }

    function haversineKm(lat1,lon1,lat2,lon2){
      if([lat1,lon1,lat2,lon2].some(v=>typeof v!=="number")) return null;
      const R=6371, toRad = d=>d*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    function median(arr){
      const v = arr.filter(n=>typeof n==="number" && !Number.isNaN(n)).sort((a,b)=>a-b);
      if(!v.length) return null;
      const m = Math.floor(v.length/2);
      return v.length%2 ? v[m] : (v[m-1]+v[m])/2;
    }

    function summarizeLinks(links, nowTs=Date.now()){
      const dayAgo = nowTs - 24*3600*1000;
      const last24 = links.filter(l=>new Date(l.ts).getTime() >= dayAgo);

      const gws = new Map();
      let bestRssi = null, bestSnr = null, airtimes=[], rssis=[], snrs=[];
      let drCount = new Map();

      for(const l of last24){
        const rssi = Number(l.rssi), snr = Number(l.snr);
        if(Number.isFinite(rssi)){ rssis.push(rssi); bestRssi = Math.max(bestRssi??-1e9, rssi); }
        if(Number.isFinite(snr)){  snrs.push(snr);  bestSnr  = Math.max(bestSnr ??-1e9, snr);  }
        if(Number.isFinite(l.airtime_ms)) airtimes.push(Number(l.airtime_ms));
        const dr = l.dr || (l.sf? `SF${l.sf}BW${l.bw||125000}`: null);
        if(dr) drCount.set(dr, (drCount.get(dr)||0)+1);

        const e = gws.get(l.gw_id) || {name:l.gw_name||l.gw_id, bestRssi:-1e9, bestSnr:-1e9, lastTs:0, lat:l.gw_lat, lon:l.gw_lon};
        if(Number.isFinite(rssi) && rssi>e.bestRssi) e.bestRssi=rssi;
        if(Number.isFinite(snr)  && snr>e.bestSnr)  e.bestSnr=snr;
        e.lastTs = Math.max(e.lastTs, new Date(l.ts).getTime());
        if(l.gw_lat!=null && l.gw_lon!=null){ e.lat=l.gw_lat; e.lon=l.gw_lon; }
        gws.set(l.gw_id, e);
      }

      let topDR = "‚Äî"; if(drCount.size){
        topDR = [...drCount.entries()].sort((a,b)=>b[1]-a[1])[0][0];
      }

      let farName="‚Äî", farKm=null;
      const nodeLat = null, nodeLon = null; // optional: falls bekannt
      if(nodeLat!=null && nodeLon!=null){
        for(const e of gws.values()){
          const d = haversineKm(nodeLat,nodeLon,e.lat,e.lon);
          if(d!=null && (farKm==null || d>farKm)){ farKm=d; farName=e.name; }
        }
      }

      let pdr = "‚Äî";
      const withCnt = last24.filter(l=>Number.isFinite(Number(l.f_cnt))).sort((a,b)=>a.f_cnt-b.f_cnt);
      if(withCnt.length>=2){
        const received = withCnt.length;
        const expected = withCnt[withCnt.length-1].f_cnt - withCnt[0].f_cnt + 1;
        if(expected>0 && received>0) pdr = Math.max(0, Math.min(100, 100*received/expected)).toFixed(0)+" %";
      }

      return {
        uplinks24: last24.length,
        gateways24: gws.size,
        bestRssi, bestSnr,
        medianRssi: median(rssis),
        medianSnr: median(snrs),
        avgAirtime: airtimes.length ? (airtimes.reduce((a,b)=>a+b,0)/airtimes.length) : null,
        topDR,
        farName, farKm,
        pdr
      };
    }

    function renderNetStats(s){
      const fmtDbm = v => (v==null || Number.isNaN(v)) ? "‚Äî" : `${v.toFixed(1).replace(".",",")} dBm`;
      const fmtDb  = v => (v==null || Number.isNaN(v)) ? "‚Äî" : `${v.toFixed(1).replace(".",",")} dB`;
      const fmtMs  = v => (v==null || Number.isNaN(v)) ? "‚Äî" : `${v.toFixed(0)} ms`;
      const fmtKm  = v => (v==null || Number.isNaN(v)) ? "‚Äî" : `${v.toFixed(1).replace(".",",")} km`;

      const cells = [
        {k:"Uplinks (24 h)", v:String(s.uplinks24), t:"Anzahl empfangener Uplinks in den letzten 24 Stunden (alle Gateways zusammen)."},
        {k:"Gateways (24 h)", v:String(s.gateways24), t:"Wie viele verschiedene Gateways haben in den letzten 24 Stunden Pakete geh√∂rt?"},
        {k:"Beste SNR", v:fmtDb(s.bestSnr), t:"Gr√∂√ütes Signal-Rausch-Verh√§ltnis eines empfangenen Pakets in den letzten 24 h."},
        {k:"Beste RSSI", v:fmtDbm(s.bestRssi), t:"Bestes (am wenigsten negatives) Empfangssignal in dBm in den letzten 24 h."},
        {k:"Median RSSI", v:fmtDbm(s.medianRssi), t:"Median der RSSI-Werte aller Uplinks der letzten 24 h."},
        {k:"√ò Airtime", v:fmtMs(s.avgAirtime), t:"Durchschnittliche Sendezeit pro Uplink (aus LoRa-PHY)."},
        {k:"H√§ufigster DR/SF", v:(s.topDR||"‚Äî"), t:"Meistgenutzte Datenrate (z. B. SF7BW125) der letzten 24 h."},
        {k:"PDR (24 h)", v:(s.pdr||"‚Äî"), t:"Packet Delivery Ratio basierend auf f_cnt-L√ºcken (sofern verf√ºgbar)."},
        {k:"weitestes GW", v:(s.farKm!=null? `${fmtKm(s.farKm)} ¬∑ ${s.farName||""}` : "‚Äî"), t:"Weitestes Gateway (nur wenn Koordinaten bekannt)."}
      ];

      const html = `
      <div class="section-title" style="margin-top:10px">Netz &amp; Gateways (24 h)</div>
      <div class="grid3">
        ${cells.map(c=>`
          <div class="tile" title="${c.t.replace(/"/g,'&quot;')}">
            <div class="k">${c.k}</div>
            <div class="v">${c.v}</div>
          </div>`).join("")}
      </div>`;
      byId("netStats").innerHTML = html;
    }

    /* --------------- Main --------------- */

    (async ()=>{
      try{
        const wanted = detectNode();
        const latest = await loadLatest();
        let entry = null;
        if(wanted){
          entry = latest.find(x=>x.id===wanted) || latest.find(x=>x.id.toLowerCase()===wanted.toLowerCase());
        }
        if(!entry) entry = latest[0];
        const node = entry.id;
        const soil = isSoilNode(node);

        byId("nodeTitle").textContent = node;
        byId("stand").textContent = entry.ts ? new Date(entry.ts).toLocaleString("de-DE") : "‚Äî";

        const {temp,hum,bat,humLabel} = pickFields(entry);
        byId("temp").textContent = temp!=null ? fmt(temp,1)+" ¬∞C" : "‚Äî";
        byId("hum").textContent  = hum!=null  ? fmt(hum,1)+" %"  : "‚Äî";
        byId("humLabel").textContent = humLabel;
        byId("bat").textContent  = bat!=null  ? fmt(bat,3)+" V"  : "‚Äî";
        byId("aktuell").innerHTML = `üå°Ô∏è Temperatur: <b>${byId("temp").textContent}</b><br>${soil?"üíß Bodenwasser":"üíß Luftfeuchte"}: <b>${byId("hum").textContent}</b><br>ü™´ Batterie: <b>${byId("bat").textContent}</b>`;

        // Netzwerk/Gateway-Statistik (ben√∂tigt /data/v2/links/<node>.json)
        const links = await loadLinks(node);
        if(links.length){
          const stats = summarizeLinks(links);
          renderNetStats(stats);
        }

        // Verlauf 7 Tage
        const hist = await loadHistory(node);
        const seven = Date.now() - 7*24*3600*1000;
        const recent = hist.filter(x=>new Date(x.ts).getTime() >= seven);
        if(recent.length){
          byId("noHourly").style.display="none";
          makeHourlyChart(byId("chartHourly").getContext("2d"), recent, soil);
        }else{
          byId("noHourly").style.display="block";
        }

        // Tagesmittel 31 Tage
        const days = groupDaily(hist);
        if(days.length){
          byId("noDaily").style.display="none";
          makeDailyChart(byId("chartDaily").getContext("2d"), days, soil);
        }else{
          byId("noDaily").style.display="block";
        }
      }catch(e){
        console.error(e);
        byId("histErr").style.display="block";
        byId("histErr").textContent = "Fehler: "+(e?.message||e);
      }
    })();
  </script>
</body>
</html>
