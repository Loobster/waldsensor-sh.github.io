<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <title>WALDSENSOR.SH â€“ V2 Karte</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .info-box {
      background: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .leaflet-top.leaflet-left .info-box { margin-top: 12px; margin-left: 12px; }
    .leaflet-top.leaflet-right .info-box { margin-top: 12px; margin-right: 12px; }
    .leaflet-control-container .leaflet-top .leaflet-control {
      margin-top: 50px;
    }
  </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// Karte
const map = L.map('map').setView([54.5, 9.5], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: 'Â© OpenStreetMap'
}).addTo(map);

// Controls fÃ¼r Aktualisierung
const leftInfo = L.control({ position: 'topleft' });
leftInfo.onAdd = () => {
  const div = L.DomUtil.create('div', 'info-box');
  div.id = 'last-refresh';
  div.textContent = 'Letzte Aktualisierung: â€“';
  return div;
};
leftInfo.addTo(map);

const rightInfo = L.control({ position: 'topright' });
rightInfo.onAdd = () => {
  const div = L.DomUtil.create('div', 'info-box');
  div.id = 'last-node';
  div.textContent = 'Letzte Node-Meldung: â€“';
  return div;
};
rightInfo.addTo(map);

// Layer fÃ¼r Marker
const markers = L.layerGroup().addTo(map);

// Mini-Versatz, falls mehrere Nodes gleiche Koordinaten haben
function tinyOffsetForId(id) {
  let h = 0;
  for (let i = 0; i < id.length; i++) h = ((h << 5) - h) + id.charCodeAt(i) | 0;
  const rand = Math.abs(h % 1000) / 1000;
  const angle = rand * 2 * Math.PI;
  const meters = 25;
  const dLat = (meters * Math.cos(angle)) / 111320;
  const dLon = (meters * Math.sin(angle)) / (40075000 * Math.cos(54*Math.PI/180) / 360);
  return { dLat, dLon };
}

// Popup HTML
function htmlPopup(row) {
  let html = `<b>${row.id}</b><br>`;
  if (row.ts) {
    const dt = new Date(row.ts);
    html += `Zeit: ${dt.toLocaleString()}<br>`;
  }
  if (row.fields) {
    if (row.fields.TempC_SHT) html += `ðŸŒ¡ Temp (SHT): <b>${row.fields.TempC_SHT.toFixed(1)} Â°C</b><br>`;
    if (row.fields.Hum_SHT)   html += `ðŸ’§ Hum (SHT): <b>${row.fields.Hum_SHT.toFixed(1)} %</b><br>`;
    if (row.fields.TempC_SHT31) html += `ðŸŒ¡ Temp (SHT31): <b>${row.fields.TempC_SHT31.toFixed(1)} Â°C</b><br>`;
    if (row.fields.Hum_SHT31)   html += `ðŸ’§ Hum (SHT31): <b>${row.fields.Hum_SHT31.toFixed(1)} %</b><br>`;
    if (row.fields.BatV)      html += `ðŸ”‹ Batterie: <b>${row.fields.BatV.toFixed(2)} V</b><br>`;
  }
  return html;
}

// JSON laden
async function loadData() {
  try {
    const res = await fetch('data/v2/latest/_all.json');
    const arr = await res.json();
    markers.clearLayers();

    let newest = null;
    arr.forEach(row => {
      if (!row.fields || !row.fields.lat || !row.fields.lon) return;
      const delta = tinyOffsetForId(row.id);
      const latDisplay = row.fields.lat + delta.dLat;
      const lonDisplay = row.fields.lon + delta.dLon;

      const marker = L.marker([latDisplay, lonDisplay]).addTo(markers);
      marker.bindPopup(htmlPopup(row));

      if (!newest || new Date(row.ts) > new Date(newest.ts)) {
        newest = row;
      }
    });

    const nowStr = new Date().toLocaleTimeString();
    document.getElementById('last-refresh').textContent = `Letzte Aktualisierung: ${nowStr}`;
    if (newest) {
      const nDate = new Date(newest.ts).toLocaleString();
      document.getElementById('last-node').textContent = `Letzte Node-Meldung: ${newest.id} â€“ ${nDate}`;
    }
  } catch (e) {
    console.error("Fehler beim Laden:", e);
  }
}

loadData();
setInterval(loadData, 300000); // alle 5 Minuten
</script>
</body>
</html>
