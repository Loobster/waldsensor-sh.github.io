<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WALDSENSOR.SH – Karte (V2)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- QRCode -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <style>
    /* REM: globale Farben/Schriften für Badges + Popup */
    :root{
      --pill-bg:#fff;
      --pill-text:#106e2a;
      --pill-shadow:0 2px 10px rgba(0,0,0,.15);
      --link:#0b4da2;
      --muted:#6a6a6a;
      --sep:#ececec;
    }
    html, body { height:100%; margin:0; }
    #map { height:100%; width:100%; }

    /* REM: Badge links (Aktualisierungszeit) */
    .pill {
      position: fixed; z-index: 1001;
      top: 12px; left: 70px;
      background: var(--pill-bg); color: var(--pill-text);
      padding: 8px 12px; border-radius: 12px;
      font: 600 14px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      box-shadow: var(--pill-shadow);
      border: 1px solid #e8e8e8;
      max-width: 44ch;
    }
    /* REM: Badge rechts (letzte Node-Meldung) */
    .last-node {
      position: fixed; z-index: 1001;
      top: 12px; right: 12px;
      background: #e9f3ff; color: var(--link);
      padding: 8px 12px; border-radius: 12px;
      font: 600 13px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      box-shadow: var(--pill-shadow);
      border: 1px solid #d6e6ff;
      max-width: 46ch; text-align: right;
    }

    /* REM: Popup-Optik, bewusst kompakt (~1/3 kleiner als früher) */
    .leaflet-popup { z-index: 1002; }
    .popup { width: 280px; }
    .popup h3{
      margin:0 0 .35rem 0;
      font: 700 16px/1.25 system-ui;
    }
    .popup .kv{
      display:grid; grid-template-columns: 1fr auto;
      column-gap: 8px; align-items: baseline;
      margin:.25rem 0;
      font: 600 13px/1.25 system-ui;
    }
    .popup .kv .label{ color:#1f1f1f; }
    .popup .kv .value{ color:#0a0a0a; }
    .popup .kv.color .value{ color:#0b4da2; } /* REM: Werte leicht farbig */
    .popup .sub { color:var(--muted); font:500 12px/1.2 system-ui; }
    .popup hr{ border:0; height:1px; background:var(--sep); margin:.35rem 0 .5rem; }

    .popup .qrrow {
      display:flex; gap:10px; align-items:center; margin-top:6px;
    }
    .popup .openbtn {
      display:inline-block; padding:8px 10px; border-radius:10px;
      background:#eef4ff; color:var(--link); font:700 14px/1.1 system-ui;
      text-decoration:none; border:1px solid #d6e6ff; white-space:nowrap;
    }
    .popup .hint { color:var(--muted); font:500 11px/1.3 system-ui; margin-top:4px; }
    .coord { font: 600 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#444; }
  </style>
</head>
<body>
  <!-- REM: Badges -->
  <div class="pill" id="stamp">Letzte Aktualisierung: –</div>
  <div class="last-node" id="last">Letzte Node-Meldung: –</div>

  <div id="map"></div>

  <script>
    /* ============================
       REM: Konstanten & Policy
       ============================ */

    // REM: Datenquelle (produktiv: relativ aus GitHub Pages)
    const DATA_URL = "/data/v2/latest/all.json";

    // REM: Auto-Refresh-Intervall (ms). 60 s ist praxisnah.
    const AUTO_REFRESH_MS = 60_000;

    // REM: IDs, die wir dauerhaft ausblenden (Alt-/Testgeräte)
    const DENY = new Set(["lsn50","lsn50-v2"]);

    // REM: Felder, die im Popup nicht gezeigt werden sollen (Debug/Technik)
    const OMIT_FIELDS = new Set([
      "ADC1_V", "EXTI_Trigger", "Door_status",
      "Digital_IStatus", "Work_mode", "Node_type", "Data_time"
    ]);

    // REM: Fallback-Koordinaten (für Geräte ohne lat/lon im Datensatz)
    const MANUAL_LOC = {
      breklum:  [54.60669, 8.98195],
      s31:      [54.65110, 8.95686],
      se01:     [54.65005, 8.96005],
      kropp:    [54.41018, 9.52839],
      fahrdorf: [54.50158, 9.58690],
      // lsn50 KEIN Eintrag (bewusst entfernt)
      // weitere bei Bedarf …
    };

    /* ============================
       REM: Leaflet-Setup
       ============================ */

    // REM: autoPanPaddingTopLeft: verhindert, dass Popups oben unter die Badges rutschen
    const map = L.map("map", {
      zoomSnap: 0.25,
      // Auto-Pan Puffer (oben/links mehr Platz wegen der Badges)
      // Hinweis: Wir setzen das beim Popup-Open zusätzlich (sicher).
    });
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>'
    }).addTo(map);
    map.setView([54.4, 9.6], 8.25);

    let markersLayer = L.layerGroup().addTo(map);

    // REM: “letzte gute” Daten gepuffert → kein Flackern bei leeren/fehlerhaften Fetches
    let lastGoodData = null;
    let lastGoodStamp = "Letzte Node-Meldung: –";
    let isFirstRender = true;

    /* ============================
       REM: Hilfsfunktionen (Format/Filter)
       ============================ */

    function normalizeId(s){
      // REM: Kurzform der ID für Darstellung/Links (konsequent klein/ohne Leerzeichen/ohne Präfix)
      return String(s||'')
        .toLowerCase()
        .replace(/\r|\s+/g,'')
        .replace(/^waldsensor[_-]/,'')
        .replace(/_/g,'-')
        .replace(/-(sn\d.*|lsn\d.*|v\d+|lb)$/,''); // “typ. Suffixe” raus für Basis-ID
    }

    function deTime(ts){
      try {
        return new Date(ts).toLocaleString("de-DE", {
          year:"numeric", month:"2-digit", day:"2-digit",
          hour:"2-digit", minute:"2-digit", second:"2-digit"
        });
      } catch(_){ return ts || "–"; }
    }

    function deNum(n, digits=1){
      return (typeof n === "number" && Number.isFinite(n))
        ? n.toLocaleString("de-DE",{minimumFractionDigits:digits, maximumFractionDigits:digits})
        : "–";
    }

    function cleanFields(fields){
      // REM: Anzeige-spezifische Bereinigung (die “echte” Bereinigung passiert idealerweise schon in Node-RED)
      const out = {};
      for (const [k,v] of Object.entries(fields || {})){
        if (OMIT_FIELDS.has(k)) continue;
        if (v === undefined || v === null || v === "NULL") continue;
        if (typeof v === "number" && !Number.isFinite(v)) continue;
        out[k] = v;
      }
      return out;
    }

    function pickCoord(item){
      // REM: 1) echte lat/lon aus payload  2) Fallback MANUAL_LOC  3) sonst null (kein Marker)
      const f = item?.fields || {};
      if (typeof f.lat !== "undefined" && typeof f.lon !== "undefined"){
        const la = Number(f.lat), lo = Number(f.lon);
        if (Number.isFinite(la) && Number.isFinite(lo)) return [la, lo];
      }
      const short = normalizeId(item.id);
      if (MANUAL_LOC[short]) return MANUAL_LOC[short];
      return null;
    }

    function latestRecord(data){
      // REM: Datensatz mit größtem TS (für rechtes Badge)
      let best = null, bestT = -Infinity;
      for (const r of (data||[])){
        if (!r || !r.ts) continue;
        const t = new Date(r.ts).getTime();
        if (!Number.isNaN(t) && t > bestT){ bestT = t; best = r; }
      }
      return best;
    }

    function popupHtml(item){
      // REM: kompaktes Popup (kleiner, klare Spalten, Koordinaten enthalten)
      const f = cleanFields(item.fields);
      const shortId = normalizeId(item.id);

      // REM: Temperatur/Feuchte priorisieren (SHT31 oder SHT)
      const temp = (typeof f.TempC_SHT31 === "number") ? f.TempC_SHT31
                  : (typeof f.TempC_SHT   === "number") ? f.TempC_SHT : null;
      const hum  = (typeof f.Hum_SHT31  === "number") ? f.Hum_SHT31
                  : (typeof f.Hum_SHT    === "number") ? f.Hum_SHT  : null;
      const bat  = (typeof f.BatV       === "number") ? f.BatV : null;

      // REM: Koordinatenanzeige (egal ob aus payload oder Fallback)
      const coord = pickCoord(item);
      const coordHtml = coord
        ? `<div class="sub coord">lat ${coord[0].toFixed(5)}, lon ${coord[1].toFixed(5)}</div>`
        : `<div class="sub">Koordinaten: –</div>`;

      let html = `<div class="popup">`;
      html += `<h3>${shortId}</h3>`;
      html += `<div class="sub">Zuletzt aktiv: ${deTime(item.ts)}</div>`;
      ${/* Trennlinie */''}
      html += `<hr/>`;

      if (bat !== null)  html += `<div class="kv color"><span class="label">Batterie</span><span class="value">${deNum(bat,3)} V</span></div>`;
      if (hum !== null)  html += `<div class="kv color"><span class="label">Luftfeuchte</span><span class="value">${deNum(hum,1)} %</span></div>`;
      if (temp !== null) html += `<div class="kv color"><span class="label">Temperatur</span><span class="value">${deNum(temp,1)} °C</span></div>`;

      // REM: sinnvolle zusätzliche Felder (Bodenwerte etc.)
      if (typeof f.temp_SOIL  === "number") html += `<div class="kv"><span class="label">Boden-Temp</span><span class="value">${deNum(f.temp_SOIL,1)} °C</span></div>`;
      if (typeof f.water_SOIL === "number") html += `<div class="kv"><span class="label">Boden-Feuchte</span><span class="value">${deNum(f.water_SOIL,1)} %</span></div>`;

      // REM: Koordinatenzeile
      html += coordHtml;

      const url = `https://www.waldsensor.sh/html/sensor.html?node=${shortId}`;
      html += `
        <div class="qrrow">
          <div id="qrcode-${shortId}"></div>
          <a class="openbtn" href="${url}" target="_blank" rel="noopener">Seite öffnen</a>
        </div>
        <div class="hint">Link nutzt Basis-ID: <b>${shortId}</b></div>
      `;

      return html + `</div>`;
    }

    function countMarkers(data){
      let c = 0;
      for (const it of (data||[])) if (!DENY.has(normalizeId(it.id)) && pickCoord(it)) c++;
      return c;
    }

    /* ============================
       REM: Laden + Rendern (no-flicker)
       ============================ */

    async function loadDataWithTimeout(url, ms=8000){
      // REM: Fetch mit Timeout, um Hänger bei Start zu vermeiden
      const ctl = new AbortController();
      const t = setTimeout(() => ctl.abort("timeout"), ms);
      try {
        const res = await fetch(`${url}?t=${Date.now()}`, { cache:"no-store", signal: ctl.signal });
        if (!res.ok) throw new Error(`fetch ${res.status}`);
        const arr = await res.json();
        if (!Array.isArray(arr)) throw new Error("JSON ist kein Array");
        return arr;
      } finally {
        clearTimeout(t);
      }
    }

    function applyBadges(data){
      // REM: Links: “Lebenszeichen” stets aktualisieren
      document.getElementById("stamp").textContent =
        "Letzte Aktualisierung: " + new Date().toLocaleTimeString("de-DE");

      // REM: Rechts: letzte Node-Meldung aus *aktuellen* Daten, sonst letzter guter Wert
      const lastRec = latestRecord(data);
      const el = document.getElementById("last");
      if (lastRec){
        lastGoodStamp = "Letzte Node-Meldung: " + deTime(lastRec.ts) + " — " + normalizeId(lastRec.id);
        el.textContent = lastGoodStamp;
      } else {
        el.textContent = lastGoodStamp || "Letzte Node-Meldung: –";
      }
    }

    function render(data){
      // REM: 1) Normieren + filtern (Denylist)
      const norm = (data||[])
        .map(x => ({ ...x, id: normalizeId(x.id), fields: cleanFields(x.fields) }))
        .filter(x => !DENY.has(x.id));

      // REM: 2) Marker zeichnen
      const bounds = [];
      markersLayer.clearLayers();

      for (const item of norm){
        const coord = pickCoord(item);
        if (!coord) continue;

        const popup = L.popup({
          autoPan: true,
          autoPanPaddingTopLeft: [20, 70],    // REM: Platz für die Badges
          autoPanPaddingBottomRight: [20, 20]
        }).setContent(popupHtml(item));

        const marker = L.marker(coord).bindPopup(popup);

        marker.on("popupopen", () => {
          // REM: QR erst beim Öffnen rendern (schnellerer Erstaufbau)
          const shortId = normalizeId(item.id);
          const qrDiv = document.getElementById(`qrcode-${shortId}`);
          const url = `https://www.waldsensor.sh/html/sensor.html?node=${shortId}`;
          if (qrDiv && !qrDiv.hasChildNodes()) {
            QRCode.toCanvas(url, { errorCorrectionLevel: 'M', width: 100 }, (err, canvas) => {
              if (!err) qrDiv.appendChild(canvas);
            });
          }
        });

        marker.addTo(markersLayer);
        bounds.push(coord);
      }

      // REM: 3) Nur beim ersten Render sanft zoomen; später Karte in Ruhe lassen
      if (bounds.length && (isFirstRender || markersLayer.getLayers().length < 3)) {
        map.fitBounds(L.latLngBounds(bounds).pad(0.12));
        isFirstRender = false;
      }

      // REM: 4) Badges aktualisieren
      applyBadges(norm);

      return norm;
    }

    async function tick(){
      try{
        const arr = await loadDataWithTimeout(DATA_URL, 8000);
        if (countMarkers(arr) > 0){
          // REM: neue brauchbare Daten → übernehmen
          lastGoodData = render(arr);
        } else if (lastGoodData){
          // REM: neue Antwort ohne Marker → alten Stand weiter anzeigen
          console.warn("Kein Marker in neuer Antwort – zeige weiterhin letzten Stand.");
          render(lastGoodData);
        } else {
          // REM: ganz am Anfang & keine Marker – einmal “leer” rendern (keine Fehler)
          console.warn("Noch kein brauchbarer Stand verfügbar.");
          render([]);
        }
      } catch (err){
        console.error("Fetch/Render-Fehler:", err);
        // REM: Bei Fehler: alten Stand zeigen (falls vorhanden) + Lebenszeichen links
        if (lastGoodData){
          render(lastGoodData);
        } else {
          applyBadges([]);
        }
      }
    }

    // REM: Initial & Intervall
    tick();
    setInterval(tick, AUTO_REFRESH_MS);
  </script>
</body>
</html>
