<!doctype html> 
<html lang="de"> 
<head> 
  <meta charset="utf-8" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1" /> 
  <title>WALDSENSOR.SH – Gateway-Karte</title> 
  <meta name="version" content="v0.19" /> 
 
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"  
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" /> 
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"  
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script> 
 
  <style> 
    :root{ 
      --ink:#0f172a; 
      --muted:#64748b; 
      --bg:#f6f8fb; 
      --card:#ffffff; 
      --success:#10b981; 
      --warning:#f59e0b; 
      --danger:#ef4444; 
      --gateway:#8b5cf6; 
    } 
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink); 
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif} 
    #map{position:absolute;inset:0} 
 
    /* HUD Badges - Informationsboxen oben auf der Karte */ 
    .badge{background:var(--card);box-shadow:0 8px 30px -16px rgba(0,0,0,.25),0 1px 0 rgba(0,0,0,. 
06); 
      border-radius:12px;padding:8px 12px;font-size:14px;font-weight:700;color:var(--ink)} 
    .badge small{display:block;font-weight:600;color:var(--muted);margin-top:2px;font-size:12px} 
 
    .hud-left{position:fixed;left:64px;top:12px;z-index:500;display:flex;flex-direction:column;gap 
:8px} 
    .hud-right{position:fixed;right:16px;top:16px;z-index:500;display:flex;flex-direction:column;g 
ap:8px;align-items:flex-end} 
    .hud-center{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:500} 
 
    /* Popup-Styling für Node- und Gateway-Informationen */ 
    .leaflet-popup-content-wrapper{border-radius:12px;box-shadow:0 12px 40px -18px rgba(0,0,0,.35) 
} 
    .leaflet-popup-content{margin:16px} 
    .popup{min-width:280px;max-width:320px;font-size:13px;line-height:1.4} 
    .popup h3{margin:0 0 12px;font-size:17px;font-weight:800;display:flex;align-items:center;gap:8 
px} 
    .popup hr{border:none;border-top:1px solid #e5e7eb;margin:12px 0} 
     
    .row{display:flex;justify-content:space-between;gap:12px;margin:6px 0;align-items:center} 
    .label{color:var(--muted);font-weight:600;font-size:12px} 
    .value{font-weight:700;font-size:13px} 
 
    /* Status-Badge für Node-Qualität */ 
    .status-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px 
; 
      font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.3px} 
    .status-excellent{background:#d1fae5;color:#065f46} 
    .status-good{background:#dbeafe;color:#1e40af} 
    .status-warning{background:#fef3c7;color:#92400e} 
    .status-critical{background:#fee2e2;color:#991b1b} 
 
    /* Info-Grid für Netzwerk-Statistiken im Popup */ 
    .info-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:10px 0} 
    .info-card{background:#f9fafb;padding:8px;border-radius:6px;text-align:center} 
    .info-card .num{font-size:18px;font-weight:800;color:var(--ink);display:block} 
    .info-card .lbl{font-size:10px;color:var(--muted);font-weight:600;text-transform:uppercase;mar 
gin-top:2px} 
 
    /* Gateway-Liste im Node-Popup */ 
    .gw-list{margin:8px 0} 
    .gw-item{background:#f9fafb;padding:6px;border-radius:6px;margin:4px 0;font-size:12px} 
    .gw-item strong{display:block;color:var(--gateway);font-size:11px;margin-bottom:2px} 
    .gw-item .signal{display:flex;justify-content:space-between;font-size:11px} 
 
    /* Sensor-Werte-Anzeige (unterscheidet Boden/Luft) */ 
    .sensor-type{font-size:11px;color:var(--muted);font-weight:600;text-transform:uppercase;margin 
:8px 0 4px} 
 
    .popup .btn{display:block;margin-top:12px;padding:10px;background:#1d4ed8;color:white; 
      border-radius:8px;font-weight:700;text-decoration:none;text-align:center;transition:backgrou 
nd 0.2s} 
    .popup .btn:hover{background:#1e40af} 
 
    /* Marker-Animationen für Nodes */ 
    @keyframes pulse-excellent { 
      0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7), 0 2px 8px rgba(0,0,0,0.2); } 
      50% { box-shadow: 0 0 0 8px rgba(16, 185, 129, 0), 0 2px 8px rgba(0,0,0,0.2); } 
    } 
 
    .marker-node { 
      width: 22px; height: 22px; background: var(--success); 
      border: 4px solid white; border-radius: 50%; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); 
      animation: pulse-excellent 2s ease-in-out infinite; 
    } 
 
    /* Gateway-Marker (lila Rauten) */ 
    .marker-gateway { 
      width: 20px; height: 20px; background: var(--gateway); 
      border: 3px solid white; border-radius: 4px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
      transform: rotate(45deg); 
    } 
 
    /* Animierte Hop-Linien zwischen Nodes und Gateways */ 
    .hop-line { 
      stroke: var(--gateway); 
      stroke-width: 2; 
      stroke-dasharray: 8, 4; 
      fill: none; 
      opacity: 0.6; 
      animation: dash 20s linear infinite; 
    } 
 
    @keyframes dash { 
      to { stroke-dashoffset: -1000; } 
    } 
  </style> 
</head> 
<body> 
  <div id="map"></div> 
 
  <!-- Linke HUD: Node- und Gateway-Zähler --> 
  <div class="hud-left"> 
    <div class="badge" id="nodesBadge">Nodes: –</div> 
    <div class="badge" id="gatewaysBadge">Gateways: –</div> 
  </div> 
 
  <!-- Zentrale HUD: Versionsnummer --> 
  <div class="hud-center"> 
    <div class="badge">v0.19 Multi-Sensor</div> 
  </div> 
 
  <!-- Rechte HUD: Letzte Meldung und Verbindungs-Statistik --> 
  <div class="hud-right"> 
    <div class="badge" id="lastBadge">Letzte Meldung: –<small id="lastBadgeAge">—</small></div> 
    <div class="badge" id="packetBadge">Verbindungen: –<small id="packetDetail">—</small></div> 
  </div> 
 
  <script> 
    // ===== Hilfsfunktionen ===== 
     
    // Konvertiert Wert zu Number, null wenn ungültig 
    const NUM = x => { 
      const n = typeof x === "number" ? x : (typeof x === "string" ? Number(x.replace(",", ".")) : 
 NaN); 
      return Number.isFinite(n) ? n : null; 
    }; 
     
    // Prüft ob Timestamp valide ist 
    const isValidISO = ts => { 
      if(!ts || typeof ts!=="string") return false; 
      return Number.isFinite(Date.parse(ts)); 
    }; 
     
    // Formatiert Timestamp für deutsche Locale 
    const formatDE = ts => isValidISO(ts) 
      ? new Date(ts).toLocaleString("de-DE",{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}) 
      : "—"; 
     
    // Berechnet relatives Alter ("vor X min") 
    const relAge = ts => { 
      if(!isValidISO(ts)) return "—"; 
      const ms = Date.now() - Date.parse(ts); 
      if(ms < 0) return "0 min"; 
      const m = Math.floor(ms/60000); 
      if(m < 60) return `${m} min`; 
      const h = Math.floor(m/60), r = m%60; 
      return `${h} h ${r} min`; 
    }; 
     
    // Formatiert Zahlen deutsch (Komma statt Punkt) 
    const deNum = (n,d=1) => (typeof n==="number" && Number.isFinite(n)) 
      ? n.toLocaleString("de-DE",{minimumFractionDigits:d,maximumFractionDigits:d}) 
      : "–"; 
    
    // Normalisiert Node-IDs (Unterstriche zu Bindestrichen) 
    // Normalisiert Node-IDs (Unterstriche zu Bindestrichen, Sonderfall Schacht-Audorf)
    function normId(id) {
      return String(id || "")
        .trim()
        .replace(/_/g, "-")
        .replace(/schacht[-_]?audorf/i, "Schacht-Audorf");
} 
    // Erkennt Boden-Sensoren (SE01-LB) anhand der ID 
    // Pattern: Name endet mit se01 oder se01lb (case-insensitive) 
    const isSoilNode = id => /(^|[-_])se01(lb)?$/i.test(String(id||"")); 
 
 
// === Multi-Sensor Erkennung === 
function getLocationKey(id) { 
  const base = String(id).replace(/[-_](s31lb|se01lb|llms01)$/i, ''); 
  return base.toLowerCase(); 
} 
 
function isMultiSensorLocation(id) { 
  return /schacht[_-]?audorf/i.test(String(id)); 
} 
 
function findRelatedNodes(nodes, baseId) { 
  const key = getLocationKey(baseId); 
  return nodes.filter(n => getLocationKey(n.id) === key); 
} 
 
    // ===== Sensor-Daten-Extraktion ===== 
     
    /** 
     * Extrahiert Temperatur-Wert basierend auf Sensor-Typ 
     * @param {Object} fields - Sensor-Felder aus all_enriched.json 
     * @param {boolean} isSoil - Ist es ein Boden-Sensor? 
     * @returns {number|null} Temperatur in °C 
     */ 
    function getTemperature(fields, isSoil) { 
      if (isSoil) { 
        // SE01-LB: Bodentemperatur 
        return NUM(fields.temp_SOIL); 
      } 
      // Luft-Sensoren: SN50v3, LSN50V2, S31-LB 
      // Versuche erst TempC_SHT (SN50v3/LSN50V2), dann TempC_SHT31 (S31-LB) 
      return NUM(fields.TempC_SHT) ?? NUM(fields.TempC_SHT31); 
    } 
 
    /** 
     * Extrahiert Feuchtigkeits-Wert basierend auf Sensor-Typ 
     * @param {Object} fields - Sensor-Felder 
     * @param {boolean} isSoil - Ist es ein Boden-Sensor? 
     * @returns {number|null} Feuchtigkeit in % 
     */ 
    function getHumidity(fields, isSoil) { 
      if (isSoil) { 
        // SE01-LB: Bodenfeuchte 
        return NUM(fields.water_SOIL); 
      } 
      // Luft-Sensoren 
      return NUM(fields.Hum_SHT) ?? NUM(fields.Hum_SHT31); 
    } 
 
    /** 
     * Gibt Label-Text für Temperatur zurück 
     */ 
    function getTempLabel(isSoil) { 
      return isSoil ? "Bodentemperatur" : "Temperatur"; 
    } 
 
    /** 
     * Gibt Label-Text für Feuchtigkeit zurück 
     */ 
    function getHumLabel(isSoil) { 
      return isSoil ? "Bodenfeuchte" : "Luftfeuchte"; 
    } 
 
    // ===== Marker-Icons ===== 
     
    function createNodeIcon() { 
      return L.divIcon({ 
        className: '', 
        html: '<div class="marker-node"></div>', 
        iconSize: [22, 22], 
        iconAnchor: [11, 11] 
      }); 
    } 
 
    function createGatewayIcon() { 
      return L.divIcon({ 
        className: '', 
        html: '<div class="marker-gateway"></div>', 
        iconSize: [20, 20], 
        iconAnchor: [10, 10] 
      }); 
    } 
 
    // ===== Popup-HTML-Generierung ===== 
   

function multiSensorPopupHtml(nodes) {
  // Titel aus Basis-ID ableiten (Suffixe -s31lb/-se01lb/-llms01 entfernen)
  const baseName = normId(String(nodes[0].id).replace(/[-_](s31lb|se01lb|llms01)$/i, ""));
  const title = baseName;

  // Neuester Timestamp über alle Nodes
  const lastTs = nodes
    .map(n => n.ts)
    .filter(ts => isValidISO(ts))
    .sort((a, b) => Date.parse(b) - Date.parse(a))[0] || null;

  // Ø Batterie über alle Nodes
  const batVals = nodes
    .map(n => NUM(n.fields?.BatV))
    .filter(v => typeof v === "number");
  const batAvg = batVals.length ? (batVals.reduce((a,b)=>a+b,0) / batVals.length) : null;

  // SF/BW vom neuesten Paket (falls vorhanden)
  let sfLatest = null, bwLatest = null;
  if (lastTs) {
    const newest = nodes
      .filter(n => isValidISO(n.ts))
      .sort((a,b)=>Date.parse(b.ts)-Date.parse(a.ts))[0];
    if (newest) {
      sfLatest = NUM(newest.fields?.sf);
      bwLatest = NUM(newest.fields?.bw);
    }
  }

  // Gateways vereinigen + beste RSSI/SNR je GW bestimmen
  const gwMap = new Map(); // id -> { id, name, rssi, snr }
  nodes.forEach(n => {
    const f = n.fields || {};
    const list = Array.isArray(n.gateway_details) ? n.gateway_details : [];
    list.forEach((gw, idx) => {
      const id = gw.id || gw.name || String(idx);
      const rssi = NUM(f[`rssi${idx+1}`]);
      const snr  = NUM(f[`snr${idx+1}`]);

      if (!gwMap.has(id)) {
        gwMap.set(id, { id, name: gw.name || id, rssi: rssi ?? null, snr: snr ?? null });
      } else {
        const rec = gwMap.get(id);
        // bestes SNR = Maximum; bestes RSSI = größter Wert (z.B. -98 ist besser als -110)
        if (typeof snr === "number" && (rec.snr == null || snr > rec.snr)) rec.snr = snr;
        if (typeof rssi === "number" && (rec.rssi == null || rssi > rec.rssi)) rec.rssi = rssi;
      }
    });
  });

  // HTML aufbauen
  let html = `<div class="popup">`;
  html += `<h3>${title} <span class="status-badge status-excellent">${nodes.length} Sensoren</span></h3>`;
  html += `<div class="row"><span class="label">Letzter Kontakt</span><span class="value">${formatDE(lastTs)}</span></div>`;
  html += `<hr/>`;

  // Info-Grid ähnlich wie beim Einzel-Node
  html += `<div class="info-grid">`;
  html += `<div class="info-card"><span class="num">${gwMap.size}</span><span class="lbl">Gateways</span></div>`;
  html += `<div class="info-card"><span class="num">${batAvg != null ? deNum(batAvg,2) : '–'}</span><span class="lbl">Batterie (Ø V)</span></div>`;
  if (sfLatest) {
    html += `<div class="info-card"><span class="num">SF${sfLatest}</span><span class="lbl">Spreading Factor</span></div>`;
  }
  html += `<div class="info-card"><span class="num">${bwLatest ? (bwLatest/1000)+'kHz' : '–'}</span><span class="lbl">Bandwidth</span></div>`;
  html += `</div>`;

  html += `<hr/>`;

  // Sensor-Blöcke (Blatt / Luft / Boden)
  nodes.forEach(n => {
    const f = n.fields || {};
    const id = String(n.id);
    const isLeaf = /llms01/i.test(id);
    const isSoil = isSoilNode(id);
    const sensorTitle = isLeaf
      ? "🍃 BLATT-SENSOR"
      : (isSoil ? "🌱 BODEN-SENSOR" : "🌡️ LUFT-SENSOR");

    html += `<div class="sensor-type">${sensorTitle}</div>`;

    if (isLeaf) {
      const t = NUM(f.Leaf_Temperature), m = NUM(f.Leaf_Moisture);
      html += `<div class="row"><span class="label">Blatttemperatur</span><span class="value">${t!=null? deNum(t,1)+' °C' : '–'}</span></div>`;
      html += `<div class="row"><span class="label">Blattfeuchte</span><span class="value">${m!=null? deNum(m,1)+' %' : '–'}</span></div>`;
    } else if (isSoil) {
      const t = NUM(f.temp_SOIL), w = NUM(f.water_SOIL);
      html += `<div class="row"><span class="label">Bodentemperatur</span><span class="value">${t!=null? deNum(t,1)+' °C' : '–'}</span></div>`;
      html += `<div class="row"><span class="label">Bodenfeuchte</span><span class="value">${w!=null? deNum(w,1)+' %' : '–'}</span></div>`;
    } else {
      const t = NUM(f.TempC_SHT) ?? NUM(f.TempC_SHT31);
      const h = NUM(f.Hum_SHT)   ?? NUM(f.Hum_SHT31);
      html += `<div class="row"><span class="label">Lufttemperatur</span><span class="value">${t!=null? deNum(t,1)+' °C' : '–'}</span></div>`;
      html += `<div class="row"><span class="label">Luftfeuchte</span><span class="value">${h!=null? deNum(h,1)+' %' : '–'}</span></div>`;
    }
    // Batterie des jeweiligen Sensors
    const bv = NUM(f.BatV);
    html += `<div class="row"><span class="label">Batterie</span><span class="value">${bv!=null? deNum(bv,2)+' V' : '–'}</span></div>`;
    html += `<div class="row"><span class="label">Details</span><span class="value"><a href="/html/sensor.html?node=${encodeURIComponent(id)}" target="_blank" rel="noopener">öffnen →</a></span></div>`;
    html += `<hr/>`;
  });

  // Einmalige Gateway-Liste (vereinigt)
  if (gwMap.size) {
    html += `<strong style="font-size:12px;color:var(--gateway)">Empfangende Gateways:</strong>`;
    html += `<div class="gw-list">`;
    Array.from(gwMap.values())
      .sort((a,b)=> (a.name||a.id).localeCompare(b.name||b.id,'de'))
      .forEach(rec => {
        html += `<div class="gw-item">`;
        html += `<strong>${rec.name || rec.id}</strong>`;
        html += `<div class="signal">`;
        html += `<span>RSSI: ${rec.rssi!=null ? rec.rssi+' dBm' : '–'}</span>`;
        html += `<span>SNR: ${rec.snr!=null ? rec.snr+' dB' : '–'}</span>`;
        html += `</div></div>`;
      });
    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

// ... dein bestehender Code bleibt ...
</script>
 
 
    /** 
     * Erzeugt Popup-HTML für ein Gateway 
     */ 
    function gatewayPopupHtml(gw, nodeCount){ 
      let html = `<div class="popup">`; 
      html += `<h3 style="color:var(--gateway)">Gateway: ${gw.name || gw.id}</h3>`; 
      html += `<div class="row"><span class="label">Aktive Nodes</span><span class="value">${nodeCount}</span></div>`; 
      html += `<div class="row"><span class="label">Position</span><span class="value">${deNum(gw.lat,5)} / ${deNum(gw.lon,5)}</span></div>`; 
      html += `</div>`; 
      return html; 
    } 
 
    // ===== Daten-Laden ===== 
     
    /** 
     * Findet den neuesten Timestamp unter allen Nodes 
     */ 
    function latestOfAll(nodes){ 
      let best = null; 
      for(const n of nodes){ 
        const ts = n.ts; 
        if(isValidISO(ts)){ 
          if(!best || Date.parse(ts) > Date.parse(best)) best = ts; 
        } 
      } 
      return best; 
    } 
 
    /** 
     * Lädt JSON mit Retry-Mechanismus (für GitHub Pages Cache-Probleme) 
     * Versucht bis zu 3x mit 2s Pause zwischen Versuchen 
     */ 
    async function fetchJson(url, retries = 3){ 
      const bust = `_=${Date.now()}`; 
      const u = url + (url.includes("?") ? "&" : "?") + bust; 
       
      for(let i = 0; i < retries; i++){ 
        try{ 
          const r = await fetch(u, { cache: "no-store" }); 
          if(!r.ok) throw new Error(`HTTP ${r.status}`); 
          const data = await r.json(); 
           
          // Validierung: Muss Array mit mindestens 1 Node sein 
          if(!Array.isArray(data) || data.length === 0){ 
            throw new Error("Empty or invalid data"); 
          } 
           
          return data; 
        }catch(e){ 
          if(i === retries - 1) throw e; 
          // Warte 2 Sekunden, dann retry 
          await new Promise(resolve => setTimeout(resolve, 2000)); 
        } 
      } 
    } 
 
    // ===== Karten-Initialisierung ===== 
     
    const map = L.map('map', { zoomControl:true, minZoom:5 }).setView([54.3, 9.7], 8); 
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {  
      maxZoom:19,  
      attribution:'&copy; OpenStreetMap'  
    }).addTo(map); 
 
    // SVG-Layer für animierte Linien 
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"); 
    svg.style.position = "absolute"; 
    svg.style.top = "0"; 
    svg.style.left = "0"; 
    svg.style.width = "100%"; 
    svg.style.height = "100%"; 
    svg.style.pointerEvents = "none"; 
    svg.style.zIndex = "400"; 
    map.getPanes().overlayPane.appendChild(svg); 
 
    /** 
     * Zeichnet animierte Hop-Linien zwischen Nodes und ihren Gateways 
     * Wird aufgerufen nach Karten-Initialisierung und bei Zoom/Pan 
     */ 
    function drawHopLines(nodes) { 
      svg.innerHTML = ""; 
      const bounds = map.getBounds(); 
      const size = map.getSize(); 
      const topLeft = map.latLngToContainerPoint(bounds.getNorthWest()); 
       
      svg.setAttribute("width", size.x); 
      svg.setAttribute("height", size.y); 
      svg.style.left = topLeft.x + "px"; 
      svg.style.top = topLeft.y + "px"; 
 
      nodes.forEach(node => { 
        const f = node.fields || {}; 
        const nodeLat = NUM(f.lat); 
        const nodeLon = NUM(f.lon); 
        if (!nodeLat || !nodeLon) return; 
 
        const gws = node.gateway_details || []; 
        gws.forEach(gw => { 
          if (!gw.lat || !gw.lon) return; 
          const nPoint = map.latLngToContainerPoint([nodeLat, nodeLon]); 
          const gPoint = map.latLngToContainerPoint([gw.lat, gw.lon]); 
           
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line"); 
          line.setAttribute("class", "hop-line"); 
          line.setAttribute("x1", nPoint.x); 
          line.setAttribute("y1", nPoint.y); 
          line.setAttribute("x2", gPoint.x); 
          line.setAttribute("y2", gPoint.y); 
          svg.appendChild(line); 
        }); 
      }); 
    } 
 
    // ===== Karten-Rendering ===== 
     
    /** 
     * Hauptfunktion: Lädt Daten und rendert Karte 
     * - Lädt all_enriched.json 
     * - Erstellt Node-Marker mit Popups 
     * - Sammelt verwendete Gateways (Deduplizierung) 
     * - Erstellt Gateway-Marker 
     * - Zeichnet Hop-Linien 
     * - Aktualisiert HUD-Badges 
     */ 
    async function render(){ 
      const nodesBadge = document.getElementById("nodesBadge"); 
      const gatewaysBadge = document.getElementById("gatewaysBadge"); 
      const lastBadge = document.getElementById("lastBadge"); 
      const lastBadgeAge = document.getElementById("lastBadgeAge"); 
      const packetBadge = document.getElementById("packetBadge"); 
      const packetDetail = document.getElementById("packetDetail"); 
 
      try{ 
        // Lade Node-Daten mit Gateway-Details 
        const nodes = await fetchJson("/data/v2/latest/all_enriched.json"); 
         
        nodesBadge.textContent = `Nodes: ${nodes.length}`; 
 
        // Sammle verwendete Gateways (ein Gateway kann von mehreren Nodes genutzt werden) 
        const usedGateways = new Map(); 
        let totalConnections = 0; 
 
        const pts = []; // Sammle alle Koordinaten für Auto-Zoom 
         
        // Erstelle Node-Marker 
        nodes.forEach(n => { 
          const f = n.fields||{}; 
          const lat = NUM(f.lat); 
          const lon = NUM(f.lon); 
          if (!lat || !lon) return; 
 
          const m = L.marker([lat, lon], { icon: createNodeIcon() }).addTo(map); 
          m.bindPopup(nodePopupHtml(n, nodes), { maxWidth: 320 }); 
          pts.push([lat, lon]); 
 
          // Zähle Gateway-Nutzung 
          const gws = n.gateway_details || []; 
          gws.forEach(gw => { 
            if (!usedGateways.has(gw.id)) { 
              usedGateways.set(gw.id, { gw, count: 0 }); 
            } 
            usedGateways.get(gw.id).count++; 
            totalConnections++; 
          }); 
        }); 
 
        // Erstelle Gateway-Marker (nur für tatsächlich genutzte Gateways) 
        usedGateways.forEach(({gw, count}) => { 
          if (!gw.lat || !gw.lon) return; 
          const m = L.marker([gw.lat, gw.lon], { icon: createGatewayIcon() }).addTo(map); 
          m.bindPopup(gatewayPopupHtml(gw, count), { maxWidth: 280 }); 
          pts.push([gw.lat, gw.lon]); 
        }); 
 
        // Aktualisiere Statistik-Badges 
        gatewaysBadge.textContent = `Gateways: ${usedGateways.size}`; 
        packetBadge.firstChild.nodeValue = `Verbindungen: ${totalConnections}`; 
        packetDetail.textContent = `Ø ${(totalConnections/nodes.length).toFixed(1)} pro Node`; 
 
        const lastTs = latestOfAll(nodes); 
        lastBadge.firstChild.nodeValue = `Letzte Meldung: ${formatDE(lastTs)}`; 
        lastBadgeAge.textContent = isValidISO(lastTs) ? `vor ${relAge(lastTs)}` : "—"; 
 
        // Auto-Zoom auf alle Marker 
        if (pts.length) { 
          const b = L.latLngBounds(pts); 
          map.fitBounds(b.pad(0.15)); 
        } 
 
        // Zeichne Hop-Linien nach kurzer Verzögerung (warten auf Karten-Rendering) 
        setTimeout(() => { 
          drawHopLines(nodes); 
          // Linien neu zeichnen bei Zoom/Pan 
          map.on('zoomend moveend', () => drawHopLines(nodes)); 
        }, 500); 
 
      }catch(e){ 
        console.error(e); 
        nodesBadge.textContent = `Fehler beim Laden`; 
        gatewaysBadge.textContent = `Gateways: –`; 
      } 
    } 
    //  -------------------- 
    // Initiales Rendering 
    render(); 
     
    // Auto-Refresh alle 5 Minuten 
    setInterval(render, 300000); 
  </script> 
</body> 
</html> 
