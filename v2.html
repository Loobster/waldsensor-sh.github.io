<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WALDSENSOR.SH ‚Äì Gateway-Karte</title>
  <meta name="version" content="v0.18" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    :root{
      --ink:#0f172a;
      --muted:#64748b;
      --bg:#f6f8fb;
      --card:#ffffff;
      --success:#10b981;
      --warning:#f59e0b;
      --danger:#ef4444;
      --gateway:#8b5cf6;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    #map{position:absolute;inset:0}

    /* HUD Badges - Informationsboxen oben auf der Karte */
    .badge{background:var(--card);box-shadow:0 8px 30px -16px rgba(0,0,0,.25),0 1px 0 rgba(0,0,0,.06);
      border-radius:12px;padding:8px 12px;font-size:14px;font-weight:700;color:var(--ink)}
    .badge small{display:block;font-weight:600;color:var(--muted);margin-top:2px;font-size:12px}

    .hud-left{position:fixed;left:64px;top:12px;z-index:500;display:flex;flex-direction:column;gap:8px}
    .hud-right{position:fixed;right:16px;top:16px;z-index:500;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
    .hud-center{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:500}

    /* Popup-Styling f√ºr Node- und Gateway-Informationen */
    .leaflet-popup-content-wrapper{border-radius:12px;box-shadow:0 12px 40px -18px rgba(0,0,0,.35)}
    .leaflet-popup-content{margin:16px}
    .popup{min-width:280px;max-width:320px;font-size:13px;line-height:1.4}
    .popup h3{margin:0 0 12px;font-size:17px;font-weight:800;display:flex;align-items:center;gap:8px}
    .popup hr{border:none;border-top:1px solid #e5e7eb;margin:12px 0}
    
    .row{display:flex;justify-content:space-between;gap:12px;margin:6px 0;align-items:center}
    .label{color:var(--muted);font-weight:600;font-size:12px}
    .value{font-weight:700;font-size:13px}

    /* Status-Badge f√ºr Node-Qualit√§t */
    .status-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px;
      font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.3px}
    .status-excellent{background:#d1fae5;color:#065f46}
    .status-good{background:#dbeafe;color:#1e40af}
    .status-warning{background:#fef3c7;color:#92400e}
    .status-critical{background:#fee2e2;color:#991b1b}

    /* Info-Grid f√ºr Netzwerk-Statistiken im Popup */
    .info-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:10px 0}
    .info-card{background:#f9fafb;padding:8px;border-radius:6px;text-align:center}
    .info-card .num{font-size:18px;font-weight:800;color:var(--ink);display:block}
    .info-card .lbl{font-size:10px;color:var(--muted);font-weight:600;text-transform:uppercase;margin-top:2px}

    /* Gateway-Liste im Node-Popup */
    .gw-list{margin:8px 0}
    .gw-item{background:#f9fafb;padding:6px;border-radius:6px;margin:4px 0;font-size:12px}
    .gw-item strong{display:block;color:var(--gateway);font-size:11px;margin-bottom:2px}
    .gw-item .signal{display:flex;justify-content:space-between;font-size:11px}

    /* Sensor-Werte-Anzeige (unterscheidet Boden/Luft) */
    .sensor-type{font-size:11px;color:var(--muted);font-weight:600;text-transform:uppercase;margin:8px 0 4px}

    .popup .btn{display:block;margin-top:12px;padding:10px;background:#1d4ed8;color:white;
      border-radius:8px;font-weight:700;text-decoration:none;text-align:center;transition:background 0.2s}
    .popup .btn:hover{background:#1e40af}

    /* Marker-Animationen f√ºr Nodes */
    @keyframes pulse-excellent {
      0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7), 0 2px 8px rgba(0,0,0,0.2); }
      50% { box-shadow: 0 0 0 8px rgba(16, 185, 129, 0), 0 2px 8px rgba(0,0,0,0.2); }
    }

    .marker-node {
      width: 22px; height: 22px; background: var(--success);
      border: 4px solid white; border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      animation: pulse-excellent 2s ease-in-out infinite;
    }

    /* Gateway-Marker (lila Rauten) */
    .marker-gateway {
      width: 20px; height: 20px; background: var(--gateway);
      border: 3px solid white; border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transform: rotate(45deg);
    }

    /* Animierte Hop-Linien zwischen Nodes und Gateways */
    .hop-line {
      stroke: var(--gateway);
      stroke-width: 2;
      stroke-dasharray: 8, 4;
      fill: none;
      opacity: 0.6;
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to { stroke-dashoffset: -1000; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Linke HUD: Node- und Gateway-Z√§hler -->
  <div class="hud-left">
    <div class="badge" id="nodesBadge">Nodes: ‚Äì</div>
    <div class="badge" id="gatewaysBadge">Gateways: ‚Äì</div>
  </div>

  <!-- Zentrale HUD: Versionsnummer -->
  <div class="hud-center">
    <div class="badge">v0.18 Multi-Sensor</div>
  </div>

  <!-- Rechte HUD: Letzte Meldung und Verbindungs-Statistik -->
  <div class="hud-right">
    <div class="badge" id="lastBadge">Letzte Meldung: ‚Äì<small id="lastBadgeAge">‚Äî</small></div>
    <div class="badge" id="packetBadge">Verbindungen: ‚Äì<small id="packetDetail">‚Äî</small></div>
  </div>

  <script>
    // ===== Hilfsfunktionen =====
    
    // Konvertiert Wert zu Number, null wenn ung√ºltig
    const NUM = x => {
      const n = typeof x === "number" ? x : (typeof x === "string" ? Number(x.replace(",", ".")) : NaN);
      return Number.isFinite(n) ? n : null;
    };
    
    // Pr√ºft ob Timestamp valide ist
    const isValidISO = ts => {
      if(!ts || typeof ts!=="string") return false;
      return Number.isFinite(Date.parse(ts));
    };
    
    // Formatiert Timestamp f√ºr deutsche Locale
    const formatDE = ts => isValidISO(ts)
      ? new Date(ts).toLocaleString("de-DE",{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"})
      : "‚Äî";
    
    // Berechnet relatives Alter ("vor X min")
    const relAge = ts => {
      if(!isValidISO(ts)) return "‚Äî";
      const ms = Date.now() - Date.parse(ts);
      if(ms < 0) return "0 min";
      const m = Math.floor(ms/60000);
      if(m < 60) return `${m} min`;
      const h = Math.floor(m/60), r = m%60;
      return `${h} h ${r} min`;
    };
    
    // Formatiert Zahlen deutsch (Komma statt Punkt)
    const deNum = (n,d=1) => (typeof n==="number" && Number.isFinite(n))
      ? n.toLocaleString("de-DE",{minimumFractionDigits:d,maximumFractionDigits:d})
      : "‚Äì";
    
    // Normalisiert Node-IDs (Unterstriche zu Bindestrichen)
    const normId = id => String(id||"").trim().replace(/_/g,"-").replace(/schacht[-_]?audorf/i,"Schacht-Audorf");
    
    // Erkennt Boden-Sensoren (SE01-LB) anhand der ID
    // Pattern: Name endet mit se01 oder se01lb (case-insensitive)
    const isSoilNode = id => /(^|[-_])se01(lb)?$/i.test(String(id||""));

    // ===== Sensor-Daten-Extraktion =====
    
    /**
     * Extrahiert Temperatur-Wert basierend auf Sensor-Typ
     * @param {Object} fields - Sensor-Felder aus all_enriched.json
     * @param {boolean} isSoil - Ist es ein Boden-Sensor?
     * @returns {number|null} Temperatur in ¬∞C
     */
    function getTemperature(fields, isSoil) {
      if (isSoil) {
        // SE01-LB: Bodentemperatur
        return NUM(fields.temp_SOIL);
      }
      // Luft-Sensoren: SN50v3, LSN50V2, S31-LB
      // Versuche erst TempC_SHT (SN50v3/LSN50V2), dann TempC_SHT31 (S31-LB)
      return NUM(fields.TempC_SHT) ?? NUM(fields.TempC_SHT31);
    }

    /**
     * Extrahiert Feuchtigkeits-Wert basierend auf Sensor-Typ
     * @param {Object} fields - Sensor-Felder
     * @param {boolean} isSoil - Ist es ein Boden-Sensor?
     * @returns {number|null} Feuchtigkeit in %
     */
    function getHumidity(fields, isSoil) {
      if (isSoil) {
        // SE01-LB: Bodenfeuchte
        return NUM(fields.water_SOIL);
      }
      // Luft-Sensoren
      return NUM(fields.Hum_SHT) ?? NUM(fields.Hum_SHT31);
    }

    /**
     * Gibt Label-Text f√ºr Temperatur zur√ºck
     */
    function getTempLabel(isSoil) {
      return isSoil ? "Bodentemperatur" : "Temperatur";
    }

    /**
     * Gibt Label-Text f√ºr Feuchtigkeit zur√ºck
     */
    function getHumLabel(isSoil) {
      return isSoil ? "Bodenfeuchte" : "Luftfeuchte";
    }

    // ===== Marker-Icons =====
    
    function createNodeIcon() {
      return L.divIcon({
        className: '',
        html: '<div class="marker-node"></div>',
        iconSize: [22, 22],
        iconAnchor: [11, 11]
      });
    }

    function createGatewayIcon() {
      return L.divIcon({
        className: '',
        html: '<div class="marker-gateway"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
    }

    // ===== Popup-HTML-Generierung =====
    
    /**
     * Erzeugt Popup-HTML f√ºr einen Node
     * Zeigt: Name, Status, Netzwerk-Stats, Sensor-Werte, Gateway-Liste
     */
    function nodePopupHtml(item){
      const f = item.fields||{};
      const title = normId(item.id);
      const when = formatDE(item.ts);
      const gwCount = f.gateway_count || 0;
      const gws = item.gateway_details || [];
      
      // Sensor-Typ erkennen
      const soil = isSoilNode(item.id);
      const temp = getTemperature(f, soil);
      const hum = getHumidity(f, soil);
      const bat = NUM(f.BatV);
      const sf = NUM(f.sf);

      let html = `<div class="popup">`;
      html += `<h3>${title} <span class="status-badge status-excellent">Aktiv</span></h3>`;
      html += `<div class="row"><span class="label">Letzter Kontakt</span><span class="value">${when}</span></div>`;
      html += `<hr/>`;
      
      // Netzwerk-Statistiken Grid
      html += `<div class="info-grid">`;
      html += `<div class="info-card"><span class="num">${gwCount}</span><span class="lbl">Gateways</span></div>`;
      html += `<div class="info-card"><span class="num">${bat ? deNum(bat,2) : '‚Äì'}</span><span class="lbl">Batterie (V)</span></div>`;
      if (sf) {
        html += `<div class="info-card"><span class="num">SF${sf}</span><span class="lbl">Spreading Factor</span></div>`;
      }
      html += `<div class="info-card"><span class="num">${f.bw ? (f.bw/1000)+'kHz' : '‚Äì'}</span><span class="lbl">Bandwidth</span></div>`;
      html += `</div>`;
      
      html += `<hr/>`;
      
      // Sensor-Werte (Boden oder Luft)
      html += `<div class="sensor-type">${soil ? 'üå± Boden-Sensor' : 'üå°Ô∏è Luft-Sensor'}</div>`;
      if (temp !== null) {
        html += `<div class="row"><span class="label">${getTempLabel(soil)}</span><span class="value">${deNum(temp,1)} ¬∞C</span></div>`;
      }
      if (hum !== null) {
        html += `<div class="row"><span class="label">${getHumLabel(soil)}</span><span class="value">${deNum(hum,1)} %</span></div>`;
      }
      
      // Gateway-Liste mit Signal-St√§rken
      if (gws.length > 0) {
        html += `<hr/><strong style="font-size:12px;color:var(--gateway)">Empfangende Gateways:</strong>`;
        html += `<div class="gw-list">`;
        gws.forEach((gw, i) => {
          const rssi = f[`rssi${i+1}`];
          const snr = f[`snr${i+1}`];
          html += `<div class="gw-item">`;
          html += `<strong>${gw.name || gw.id}</strong>`;
          if (rssi !== undefined || snr !== undefined) {
            html += `<div class="signal">`;
            html += `<span>RSSI: ${rssi ? rssi+' dBm' : '‚Äì'}</span>`;
            html += `<span>SNR: ${snr ? snr+' dB' : '‚Äì'}</span>`;
            html += `</div>`;
          }
          html += `</div>`;
        });
        html += `</div>`;
      }
      
      // Link zur Detail-Seite
      const statHref = `/html/sensor.html?node=${encodeURIComponent(item.id)}`;
      html += `<a class="btn" href="${statHref}" target="_blank" rel="noopener">Detailansicht √∂ffnen ‚Üí</a>`;
      html += `</div>`;
      return html;
    }

    /**
     * Erzeugt Popup-HTML f√ºr ein Gateway
     */
    function gatewayPopupHtml(gw, nodeCount){
      let html = `<div class="popup">`;
      html += `<h3 style="color:var(--gateway)">Gateway: ${gw.name || gw.id}</h3>`;
      html += `<div class="row"><span class="label">Aktive Nodes</span><span class="value">${nodeCount}</span></div>`;
      html += `<div class="row"><span class="label">Position</span><span class="value">${deNum(gw.lat,5)} / ${deNum(gw.lon,5)}</span></div>`;
      html += `</div>`;
      return html;
    }

    // ===== Daten-Laden =====
    
    /**
     * Findet den neuesten Timestamp unter allen Nodes
     */
    function latestOfAll(nodes){
      let best = null;
      for(const n of nodes){
        const ts = n.ts;
        if(isValidISO(ts)){
          if(!best || Date.parse(ts) > Date.parse(best)) best = ts;
        }
      }
      return best;
    }

    /**
     * L√§dt JSON mit Retry-Mechanismus (f√ºr GitHub Pages Cache-Probleme)
     * Versucht bis zu 3x mit 2s Pause zwischen Versuchen
     */
    async function fetchJson(url, retries = 3){
      const bust = `_=${Date.now()}`;
      const u = url + (url.includes("?") ? "&" : "?") + bust;
      
      for(let i = 0; i < retries; i++){
        try{
          const r = await fetch(u, { cache: "no-store" });
          if(!r.ok) throw new Error(`HTTP ${r.status}`);
          const data = await r.json();
          
          // Validierung: Muss Array mit mindestens 1 Node sein
          if(!Array.isArray(data) || data.length === 0){
            throw new Error("Empty or invalid data");
          }
          
          return data;
        }catch(e){
          if(i === retries - 1) throw e;
          // Warte 2 Sekunden, dann retry
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }

    // ===== Karten-Initialisierung =====
    
    const map = L.map('map', { zoomControl:true, minZoom:5 }).setView([54.3, 9.7], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
      maxZoom:19, 
      attribution:'&copy; OpenStreetMap' 
    }).addTo(map);

    // SVG-Layer f√ºr animierte Linien
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = "none";
    svg.style.zIndex = "400";
    map.getPanes().overlayPane.appendChild(svg);

    /**
     * Zeichnet animierte Hop-Linien zwischen Nodes und ihren Gateways
     * Wird aufgerufen nach Karten-Initialisierung und bei Zoom/Pan
     */
    function drawHopLines(nodes) {
      svg.innerHTML = "";
      const bounds = map.getBounds();
      const size = map.getSize();
      const topLeft = map.latLngToContainerPoint(bounds.getNorthWest());
      
      svg.setAttribute("width", size.x);
      svg.setAttribute("height", size.y);
      svg.style.left = topLeft.x + "px";
      svg.style.top = topLeft.y + "px";

      nodes.forEach(node => {
        const f = node.fields || {};
        const nodeLat = NUM(f.lat);
        const nodeLon = NUM(f.lon);
        if (!nodeLat || !nodeLon) return;

        const gws = node.gateway_details || [];
        gws.forEach(gw => {
          if (!gw.lat || !gw.lon) return;
          const nPoint = map.latLngToContainerPoint([nodeLat, nodeLon]);
          const gPoint = map.latLngToContainerPoint([gw.lat, gw.lon]);
          
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("class", "hop-line");
          line.setAttribute("x1", nPoint.x);
          line.setAttribute("y1", nPoint.y);
          line.setAttribute("x2", gPoint.x);
          line.setAttribute("y2", gPoint.y);
          svg.appendChild(line);
        });
      });
    }

    // ===== Karten-Rendering =====
    
    /**
     * Hauptfunktion: L√§dt Daten und rendert Karte
     * - L√§dt all_enriched.json
     * - Erstellt Node-Marker mit Popups
     * - Sammelt verwendete Gateways (Deduplizierung)
     * - Erstellt Gateway-Marker
     * - Zeichnet Hop-Linien
     * - Aktualisiert HUD-Badges
     */
    async function render(){
      const nodesBadge = document.getElementById("nodesBadge");
      const gatewaysBadge = document.getElementById("gatewaysBadge");
      const lastBadge = document.getElementById("lastBadge");
      const lastBadgeAge = document.getElementById("lastBadgeAge");
      const packetBadge = document.getElementById("packetBadge");
      const packetDetail = document.getElementById("packetDetail");

      try{
        // Lade Node-Daten mit Gateway-Details
        const nodes = await fetchJson("/data/v2/latest/all_enriched.json");
        
        nodesBadge.textContent = `Nodes: ${nodes.length}`;

        // Sammle verwendete Gateways (ein Gateway kann von mehreren Nodes genutzt werden)
        const usedGateways = new Map();
        let totalConnections = 0;

        const pts = []; // Sammle alle Koordinaten f√ºr Auto-Zoom
        
        // Erstelle Node-Marker
        nodes.forEach(n => {
          const f = n.fields||{};
          const lat = NUM(f.lat);
          const lon = NUM(f.lon);
          if (!lat || !lon) return;

          const m = L.marker([lat, lon], { icon: createNodeIcon() }).addTo(map);
          m.bindPopup(nodePopupHtml(n), { maxWidth: 320 });
          pts.push([lat, lon]);

          // Z√§hle Gateway-Nutzung
          const gws = n.gateway_details || [];
          gws.forEach(gw => {
            if (!usedGateways.has(gw.id)) {
              usedGateways.set(gw.id, { gw, count: 0 });
            }
            usedGateways.get(gw.id).count++;
            totalConnections++;
          });
        });

        // Erstelle Gateway-Marker (nur f√ºr tats√§chlich genutzte Gateways)
        usedGateways.forEach(({gw, count}) => {
          if (!gw.lat || !gw.lon) return;
          const m = L.marker([gw.lat, gw.lon], { icon: createGatewayIcon() }).addTo(map);
          m.bindPopup(gatewayPopupHtml(gw, count), { maxWidth: 280 });
          pts.push([gw.lat, gw.lon]);
        });

        // Aktualisiere Statistik-Badges
        gatewaysBadge.textContent = `Gateways: ${usedGateways.size}`;
        packetBadge.firstChild.nodeValue = `Verbindungen: ${totalConnections}`;
        packetDetail.textContent = `√ò ${(totalConnections/nodes.length).toFixed(1)} pro Node`;

        const lastTs = latestOfAll(nodes);
        lastBadge.firstChild.nodeValue = `Letzte Meldung: ${formatDE(lastTs)}`;
        lastBadgeAge.textContent = isValidISO(lastTs) ? `vor ${relAge(lastTs)}` : "‚Äî";

        // Auto-Zoom auf alle Marker
        if (pts.length) {
          const b = L.latLngBounds(pts);
          map.fitBounds(b.pad(0.15));
        }

        // Zeichne Hop-Linien nach kurzer Verz√∂gerung (warten auf Karten-Rendering)
        setTimeout(() => {
          drawHopLines(nodes);
          // Linien neu zeichnen bei Zoom/Pan
          map.on('zoomend moveend', () => drawHopLines(nodes));
        }, 500);

      }catch(e){
        console.error(e);
        nodesBadge.textContent = `Fehler beim Laden`;
        gatewaysBadge.textContent = `Gateways: ‚Äì`;
      }
    }

    // Initiales Rendering
    render();
    
    // Auto-Refresh alle 5 Minuten
    setInterval(render, 300000);
  </script>
</body>
</html>
